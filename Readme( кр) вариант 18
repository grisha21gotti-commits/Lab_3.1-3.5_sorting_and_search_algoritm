Практическая работа. Вариант 18  
Тема: Табу-поиск для раскраски графа

 Постановка задачи

Необходимо реализовать табу-поиск для задачи раскраски неориентированного графа.

Цель: раскрасить вершины графа в минимальное количество цветов так, чтобы никакие две смежные вершины не имели одинакового цвета (минимизация числа цветов и количества конфликтов).


Входные данные

Ввод осуществляется с клавиатуры.

Формат:

1. n — количество вершин графа;  
2. m — количество рёбер;  
3. далее m строк вида  
   u v — неориентированное ребро между вершинами u и v, вершины нумеруются с 1.

Пример входа:

```text
12
14
1 2
1 3
2 4
2 5
3 6
3 7
4 8
5 8
6 9
7 9
8 10
9 11
10 12
11 12

Выходные данные

Программа должна вывести:
 1. минимальное найденное число цветов;
 2. цвет каждой вершины.

Формат вывода:
Минимальное найденное количество цветов: K
Раскраска вершин:
Вершина 1: цвет c1
Вершина 2: цвет c2
...
Вершина n: цвет cn
где K — минимальное найденное алгоритмом количество цветов,
ci — цвет вершины i (нумерация цветов с 1).

Краткое описание алгоритма

1. Представление решения
 • пусть n — число вершин;
 • решение — массив colors длины n:
 • colors[v] — цвет вершины v (внутри программы — числа от 0 до k-1).

Функция стоимости — количество конфликтов:
 • конфликт — это ребро (u, v), у которого colors[u] == colors[v];
 • задача табу-поиска — минимизировать число конфликтов (идеально сделать его равным 0).

2. Окрестность решения

Окрестность текущей раскраски:
 • выбираем вершину v,
 • перекрашиваем её в любой другой цвет c из {0, 1, ..., k-1}, отличный от текущего.

Каждый такой ход (v, c) — соседнее решение.

3. Табу-лист

Табу-лист нужен, чтобы алгоритм не зацикливался, постоянно переходя между одними и теми же решениями. 
 • В табу-листе храним последние изменения цвета (v, c) — «вершина v покрашена в цвет c».
 • Размер табу-списка ограничен (в варианте 18 используем 10 последних ходов).
 • При каждом ходе:
 • добавляем (v, c) в конец табу-списка,
 • если длина превысила 10 — удаляем самый старый ход.
 • При выборе следующего хода:
 • ходы из табу-списка запрещены,
кроме случая, когда выполняется критерий аспирации.

Критерий аспирации:
если ход табу, но приводит к лучшему глобальному значению функции стоимости
(число конфликтов становится меньше, чем было когда-либо), —
запрет снимается, ход можно сделать.


4. Схема работы табу-поиска

Для фиксированного числа цветов k:
 1. Сгенерировать начальное решение — случайную раскраску colors.
 2. На каждой итерации (всего 500 итераций):
 • перебрать все возможные ходы (v, c) (перекрасить одну вершину в другой цвет);
 • для каждого хода посчитать, сколько конфликтов будет после него;
 • выбрать среди разрешённых ходов тот, который даёт минимальное число конфликтов;
 • применить этот ход, обновить табу-список;
 • если текущее число конфликтов стало лучшим (меньшим, чем было), — запомнить это решение.
 3. Если число конфликтов стало 0, можно остановиться раньше 500 итераций — найдена корректная раскраска при данном k.

5. Уменьшение числа цветов

Задача раскраски — найти минимальное количество цветов.

Алгоритм делает так:
 1. Для заданного графа считаем максимальную степень вершины Δ.
Из теории графов: граф можно раскрасить не более чем в Δ + 1 цвет.
 2. Строим начальную раскраску с k_start = Δ + 1 цветов жадным алгоритмом, без конфликтов.
 3. Запускаем табу-поиск с меньшим числом цветов:
 • пробуем k = k_start - 1, k_start - 2, …, 1;
 • для каждого k запускаем табу-поиск на 500 итераций;
 • если удалось получить раскраску без конфликтов (конфликтов 0) — запоминаем её и идём к ещё меньшему k;
 • как только для некоторого k не удаётся избавиться от конфликтов, останавливаемся.
 4. Результат — лучшая раскраска и соответствующее минимальное число цветов K.


6. Оценка сложности

Пусть:
 • n — число вершин,
 • m — число рёбер,
 • k — число цветов.

На одной итерации:
 • перебираем все возможные ходы (v, c) — порядка O(n·k);
 • для каждого считаем число конфликтов за O(m).

Итого:
 • одна итерация — O(n·k·m);
 • 500 итераций дают O(500·n·k·m) — для учебного графа с 10–12 вершинами это быстро.
Контрольные вопросы и краткие ответы

(по разделу 1–2 методички: приближённые и эвристические алгоритмы) 
 1. Что такое приближённый алгоритм и какова его цель?
Приближённый алгоритм — алгоритм для NP-сложной оптимизационной задачи, который за полиномиальное время выдаёт решение, близкое к оптимальному, с оцениваемым отклонением от оптимума (коэффициент аппроксимации).
 2. Коэффициент аппроксимации α для задачи минимизации. Что он характеризует?
Для задачи минимизации алгоритм A — α-аппроксимация, если
A(I) ≤ α · OPT(I) для любого входа I, где OPT(I) — оптимальное значение, α ≥ 1.
Он показывает, во сколько раз решение алгоритма может быть хуже оптимального.
 3. Чем отличаются PTAS и FPTAS?
 • PTAS (Polynomial-Time Approximation Scheme) — схема, позволяющая для любого ε>0 получить (1+ε)-приближённое решение за полиномиальное время по размеру входа (но, как правило, экспоненциальное по 1/ε).
 • FPTAS (Fully PTAS) — время полиномиально и по размеру входа, и по 1/ε.
 4. Почему жадный алгоритм для вершинного покрытия даёт 2-аппроксимацию?
В каждом шаге выбирается ребро и обе его вершины добавляются в покрытие.
Любое оптимальное покрытие должно содержать хотя бы одну вершину из каждого выбранного ребра, значит оптимальное покрытие содержит не меньше вершин, чем число выбранных рёбер. Мы берём по две вершины на ребро → размер покрытия не более чем в 2 раза больше оптимального.
 5. Почему жадный алгоритм для 0–1 рюкзака не гарантирует оптимальное решение?
Он сортирует предметы по удельной стоимости value/weight и выбирает самые «выгодные». Для 0–1 рюкзака такая стратегия может «переполнить» рюкзак малым числом дорогих, но тяжёлых предметов и не оставить места для более выгодного набора. Хрестоматийный контрпример: один предмет большой ценности, но чуть тяжелее двух оптимальных поменьше.
 6. В чём различие дробного и 0–1 рюкзака?
 • Дробный: предмет можно взять частично (любую долю веса).
 • 0–1: предмет берётся либо полностью, либо не берётся вообще.
Жадный алгоритм по value/weight оптимален только для дробного рюкзака.
 7. Какой коэффициент аппроксимации у жадного алгоритма составления расписания на m машинах?
Для классического жадного алгоритма (каждую новую работу кладём на машину с минимальной текущей загрузкой) коэффициент аппроксимации равен 2(1 − 1/m).
 8. В чём суть алгоритма Кристофидеса и почему он даёт 1.5-аппроксимацию для метрического TSP?
Этапы:
 1. строим минимальное остовное дерево;
 2. добавляем минимальное совершенное паросочетание на вершинах нечётной степени;
 3. получаем эйлеров граф, находим эйлеров обход;
 4. делаем «shortcut» (обход без повторов вершин).
Доказано, что полученный тур не длиннее 1.5 · OPT.
 9. Какой коэффициент аппроксимации у жадного алгоритма покрытия множеств?
Жадный алгоритм, который каждый раз выбирает множество, покрывающее максимум ещё не покрытых элементов, имеет коэффициент аппроксимации H(n) ≈ ln n, где n — размер универсума.
 10. Чем эвристические алгоритмы отличаются от приближённых?
 • приближённые алгоритмы имеют формальную гарантию качества решения (коэффициент аппроксимации);
 • эвристические алгоритмы такой гарантии не дают, но часто работают быстро и хорошо на практике (примеры: табу-поиск, имитация отжига, генетические алгоритмы).
 11. Имитация отжига: принцип работы и роль температуры.
Имитация отжига имитирует физический процесс охлаждения: при высокой температуре алгоритм может принимать «плохие» ходы (ухудшающие решение) с определённой вероятностью, чтобы выйти из локальных минимумов; по мере снижения температуры вероятность принятия плохих ходов падает, поиск «затвердевает».
 12. Табу-поиск: основная идея и роль табу-листа.
Табу-поиск — локальный поиск с памятью: на каждом шаге выбирается лучшее соседнее решение, но некоторая часть ходов запрещена табу-листом (недавние действия). Табу-лист не даёт алгоритму возвращаться к недавно посещённым решениям и зацикливаться; критерий аспирации позволяет игнорировать табу, если ход даёт новое глобально лучшее решение.
