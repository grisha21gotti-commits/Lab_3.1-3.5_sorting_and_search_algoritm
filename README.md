# Lab_3.1-3.5_sorting_and_search_algoritm
Лабораторная работа 3.1–3.5
Тема: Алгоритмы сортировки и поиска
Цель: Анализ и практическая реализация алгоритмов сортировки и поиска с оценкой их временной сложности в нотации Big O.
 Содержание
 1. Блочная (корзинная) сортировка
 2. Блинная сортировка
 3. Сортировка бусинами (гравитационная)
 4. Поиск скачками
 5. Экспоненциальный поиск
 6. Тернарный поиск

 Блочная (корзинная) сортировка
1)Определение: Блочная сортировка (bucket sort) — это алгоритм, который распределяет
элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины
объединяются обратно в один массив.

 4)Принцип работы блочной (корзинной) сортировки
 1. Определяется количество корзин — исходя из диапазона значений элементов или по эвристике √n (чтобы сохранить баланс между числом корзин и размером каждой).
 2. Определяется диапазон данных — находятся минимальное и максимальное значения массива, чтобы рассчитать размах max − min.
 3. Создаются пустые корзины — для каждого диапазона значений формируется отдельная коллекция (список).
 4. Каждый элемент помещается в корзину согласно функции распределения index = int((x − min)/(max − min) × (bucket_count − 1)), которая вычисляет индекс корзины по нормализованному значению.
 5. Элементы внутри корзин сортируются индивидуально — для каждой корзины вызывается стабильный алгоритм вставок (insertion sort), который упорядочивает содержимое.
 6. Происходит объединение корзин — отсортированные корзины соединяются слева направо в порядке возрастания диапазонов.
 7. Формируется итоговый массив — объединённый список возвращается как результат работы алгоритма.
 8. Используемые операторы языка Python:
 • def — определение функций bucket_sort и insertion_sort;
 • for и while — циклы распределения и сортировки элементов;
 • if — проверка условий (если массив пуст, если все элементы равны);
 • return — возврат результата работы алгоритма.
5) Оценка временной сложности алгоритма
 • Лучшая (Best Case): O(n + k)
 • Средняя (Average Case): O(n + k)
 • Худшая (Worst Case): O(n²)

где
 • n — количество элементов в массиве,
 • k — число корзин.
 6) Пояснение оценки сложности
  • Лучшая и средняя случаи O(n + k):
Если элементы распределяются по корзинам равномерно, каждая корзина содержит примерно n/k элементов.
Тогда вставка элементов в корзины и их локальная сортировка выполняются почти за линейное время, потому что сортировка маленьких подсписков вставками (insertion sort) работает быстро при малом размере.
Суммарное время на распределение (O(n)) + на сортировку внутри корзин (O(k)) ≈ O(n + k).
 • Худший случай O(n²):
Если распределение неравномерное (все элементы попали в одну корзину), то алгоритм фактически превращается в простую сортировку вставками, где каждая операция вставки сдвигает элементы — что даёт квадратичную зависимость от n.
 • Таким образом, эффективность блочной сортировки напрямую зависит от функции распределения и равномерности данных:
при удачном выборе диапазонов она близка к линейной O(n),
а при неудачном — деградирует до O(n²).


2) БЛИННАЯ СОРТИРОВКА (PANCAKE SORT)

Блинная сортировка (pancake sort) — это метод, основанный на операции переворота части массива. На каждом шаге алгоритм ищет максимальный элемент и переворачивает часть массива, чтобы поместить этот элемент в конец.

Принцип работы:
 • Находится индекс максимального элемента в неотсортированной части массива
 • Переворачивается подмассив от начала до максимального элемента
 • Переворачивается вся неотсортированная часть массива
 • Процесс повторяется для оставшейся части массива

Использованные операторы и функции:
 • def — объявление функций flip, find_max, pancake_sort
 • while — переворот элементов массива
 • for i in range(...) — проход по элементам
 • if arr[i] > arr[max_i]: — поиск максимального
 • return arr — возврат отсортированного списка
 • print() — вывод результата

Сложность:
O(n²)

Обоснование:
На каждом шаге выполняется поиск максимального элемента (O(n)) и переворот (O(n)), а шагов всего n → итог O(n²).

Исходный массив: [3, 6, 1, 10, 2, 7]
Отсортированный массив: [1, 2, 3, 6, 7, 10]

⸻

3) СОРТИРОВКА БУСИНАМИ (BEAD SORT)

Сортировка бусинами (bead sort) — имитирует естественное падение бусин под действием силы тяжести. Каждый элемент представлен в виде ряда бусин, количество которых соответствует его значению.

Принцип работы:
 • Определяется максимальное значение массива
 • Для каждого элемента создаётся строка бусин (1 и 0)
 • Для каждого столбца подсчитывается количество бусин и они “оседают” вниз
 • После завершения «падения» строки суммируются, формируя новый массив

Использованные операторы и функции:
 • any(x < 0 for x in arr) — проверка отрицательных значений
 • max(arr) — поиск максимума
 • Списковое включение [1]*x + [0]*(max_val-x) — создание строк бусин
 • Вложенные циклы for j in range() и for i in range()
 • sum(row[j] for row in beads) — подсчёт количества бусин в столбце
 • if i >= len(arr) - col_sum — условие для “падения” бусин
 • sum(row) — получение нового значения элемента

Сложность:
O(n × max(Aᵢ))

Обоснование:
Количество операций зависит от числа элементов и максимального значения. Каждая бусина перемещается один раз.

Исходный массив: [5, 3, 1, 7, 4]
Отсортированный массив: [1, 3, 4, 5, 7]

⸻
4) ПОИСК СКАЧКАМИ (JUMP SEARCH)

Поиск скачками — это алгоритм для отсортированных массивов, который делает прыжки через фиксированные интервалы и после превышения искомого значения выполняет линейный поиск в найденном блоке.

Принцип работы:
 • Определяется длина шага step = √n
 • Выполняются прыжки через равные промежутки
 • Когда элемент превышает целевой — выполняется линейный поиск в предыдущем блоке
 • Возвращается индекс найденного элемента или -1

Использованные операторы и функции:
 • import math — подключение модуля для вычисления √n
 • while — выполнение прыжков
 • min(step, n) — проверка границ массива
 • for i in range(prev, min(step, n)): — линейный поиск внутри блока
 • if arr[i] == target: — сравнение с искомым
 • return i / return -1 — возврат результата

Сложность:
O(√n)

Обоснование:
Выполняется примерно √n прыжков и столько же сравнений при линейном поиске, суммарно O(√n).

Исходный массив: [1, 3, 5, 7, 9, 11, 13, 15]
Искомый элемент: 9
Результат: индекс 4

⸻

5) ЭКСПОНЕНЦИАЛЬНЫЙ ПОИСК (EXPONENTIAL SEARCH)

Экспоненциальный поиск сочетает последовательный и двоичный поиск, быстро увеличивая диапазон, пока не будет найден интервал, содержащий целевой элемент.

Принцип работы:
 • Проверяется первый элемент массива
 • Интервал увеличивается в степенях двойки (1, 2, 4, 8, …)
 • После превышения значения выполняется бинарный поиск на найденном участке
 • Возвращается индекс найденного элемента

Использованные операторы и функции:
 • while — экспоненциальное увеличение интервала
 • if arr[0] == target: — проверка первого элемента
 • binary_search() — вызов вспомогательной функции
 • mid = (left + right)//2 — вычисление середины диапазона
 • if, elif, else — сравнение значений
 • return — возврат результата

Сложность:
O(log n)

Обоснование:
Интервал увеличивается логарифмически, а бинарный поиск также выполняется за O(log n).

Исходный массив: [2, 4, 6, 8, 10, 12, 14, 16]
Искомый элемент: 14
Результат: индекс 6

⸻

6) ТЕРНАРНЫЙ ПОИСК (TERNARY SEARCH)

Тернарный поиск — это модификация двоичного поиска, при которой диапазон делится на три части и сравнивается с элементами на двух разделительных границах.

Принцип работы:
 • Делится диапазон на три части (mid1, mid2)
 • Сравнивается целевой элемент с arr[mid1] и arr[mid2]
 • Если найдено совпадение — возвращается индекс
 • Иначе поиск продолжается в одной из трёх частей

Использованные операторы и функции:
 • while left <= right: — цикл по диапазону
 • third = (right - left)//3 — вычисление делителя
 • if, elif, else — проверка условий
 • return mid1 / mid2 / -1 — возврат результата
 • print() — вывод найденного индекса

Сложность:
O(log₃ n) ≈ O(log n)

Обоснование:
На каждом шаге диапазон сокращается втрое, что делает поиск логарифмическим по времени.

Исходный массив: [1, 3, 5, 7, 9, 11, 13]
Искомый элемент: 11
Результат: индекс 5
